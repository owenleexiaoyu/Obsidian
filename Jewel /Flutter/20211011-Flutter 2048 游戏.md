最近在学习 Flutter 的一些知识，想着独立写一个小示例来运用一下所学的东西，所以就有了这个Flutter 版本 2048 小游戏的项目。完整代码请戳 [Github]()。

2048 小游戏曾经也是风靡一时呀，应该很多人都玩过，不过我们还是简单说一下这个游戏的机制，这里有个网页版的 [2048](https://play2048.co/)，大家可以实际体验一下。一般来说，它是一个 4 * 4 的棋盘，共有 16 个小格子，每个格子中，要么是空格，要么有一个数字，玩家可以上下左右四个方向去滑动（或者通过键盘方向键控制）。当左右滑动时，同一行上数字格子会被移到最左端或者最右端，中间没有空格，相邻的相同数字的格子合并成一个，数字是之前两个格子数字之和，比如 2 和 2 会合并成 4 和 空格。每次滑动后有格子移动时，就会在棋盘的空格里随机生成一个数字。终极的目标是合并出 2048 这个数字。

好的，介绍完这个游戏怎么玩后，我们就可以进入正题，开始实现我们 Flutter 版本的 2048 了。

我们最终实现的效果如下：

<img src="https://gitee.com/owenlee233/image_store/raw/master/202110241555714.png" alt="UI" style="zoom:33%;" />

### UI 界面

从上面的效果图我们可以看到，这个游戏界面可以分为两部分，一个是上方的标题、分数、历史最高分、重新开始游戏按钮等元素：

<img src="https://gitee.com/owenlee233/image_store/raw/master/202110241558113.png" alt="header" style="zoom:33%;" />

一个是下方的棋盘部分，有 4 * 4 个小格子：

<img src="https://gitee.com/owenlee233/image_store/raw/master/202110241559350.png" alt="panel" style="zoom:33%;" />

如果游戏结束时，这部分上面还会盖有一个游戏结束的蒙层：

<img src="https://gitee.com/owenlee233/image_store/raw/master/202110241601378.png" alt="mask" style="zoom:33%;" />

游戏整体 UI 的代码，精简一下是这样的：

```dart
class Game2048Page extends StatefulWidget {
  @override
  _Game2048PageState createState() => _Game2048PageState();
}

class _Game2048PageState extends State<Game2048Page> {

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      extendBodyBehindAppBar: true,
      body: Container(
        padding: EdgeInsets.only(top: 30),
        color: GameColors.bgColor1,
        child: Column(
          children: [
            Flexible(child: gameHeader()),
            Flexible(flex: 2,child: Game2048Panel())
          ],
        )
      ),
    );
  }

  // 省略了代码
  Widget gameHeader() {
    return Container();
  }
}
```

因为界面里需要展示变化的当前分数和历史最高分数，所以 `Game2048Page` 是继承自 `StatefulWidget`。布局结构整体是一个 Column 的垂直方向布局，上面是 `gameHeader()`，抽成了一个方法，里面就是标题、描述、分数等信息，下面是 `Game2048Panel` 表示棋盘，定义成了一个 Widget，Header 和 Panel 是 1 ：2 的高度比例（这个后面会提到是干嘛的）。

#### Header 部分

Header 部分比较简单，就粗略介绍一下，我们需要展示当前的分数和历史最高分，所以在 `_Game2048PageState` 中定义两个变量，并在相应的 UI 元素中展示出来，分数下方还有个 New Game 的按钮，点击按钮可以重新开始游戏。这部分 UI 代码精简后是这样的，重新开始游戏的逻辑我们后面再实现。

```dart
class _Game2048PageState extends State<Game2048Page> {

  /// 当前分数
  int currentScore = 0;
  /// 历史最高分
  int highestScore = 0;
 
  Widget gameHeader() {
  	return Row(
    	children: [
        Text("2048"),
        Column(
          children: [
            Text(currentScore.toString()),
            Text(highestScore.toString()),
            ElevatedButton(
            	onPressed: () {
                // 重新开始游戏，这里的逻辑之后再实现
              },
              child: Text("New Game"),
            )
          ]
        ),
      ]
    )
  }
}
```

#### Panel 部分

Panel 部分我定义成了一个叫做 Game2048Panel 的 Widget，继承自 StatefulWidget，因为内部有是否游戏结束等状态。UI 部分，当游戏结束时，我们使用 Stack 布局，蒙层盖在棋盘的上方，游戏没有结束时，只有棋盘。棋盘宽高比是 1 : 1，使用 AspectRatio 组件，棋盘可以识别用户上下左右滑动的手势，所以需要 GestureDetector 组件，棋盘中 4 * 4 的小格子，用 GridView 来实现。`Game2048Panel` 的 UI 结构大致如下图所示：

![panel-ui](https://gitee.com/owenlee233/image_store/raw/master/202110241710234.png)

这部分整体的代码精简一下（去掉了 UI 细节）是这样的：

```dart
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter_games/games/2048/game_colors.dart';

class Game2048Panel extends StatefulWidget {
  final ValueChanged<int>? onScoreChanged;

  Game2048Panel({Key? key, this.onScoreChanged}) : super(key: key);

  @override
  Game2048PanelState createState() => Game2048PanelState();
}

class Game2048PanelState extends State<Game2048Panel> {
  /// 每行每列的个数
  static const int SIZE = 4;

  /// 判断是否游戏结束
  bool _isGameOver = false;

  @override
  Widget build(BuildContext context) {
    if (_isGameOver) {
      return Stack(
        children: [
          _buildGamePanel(context),
          _buildGameOverMask(context),
        ],
      );
    } else {
      return _buildGamePanel(context);
    }
  }

  Widget _buildGamePanel(BuildContext context) {
    return GestureDetector(
      child: AspectRatio(
        aspectRatio: 1.0,
        child: Container(
          child: MediaQuery.removePadding(
            /// GridView 默认顶部会有 padding，通过这个删除顶部 padding
            removeTop: true,
            context: context,
            child: GridView.builder(
              /// 禁用 GridView 的滑动
              physics: const NeverScrollableScrollPhysics(),
              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: SIZE,
              ),
              itemCount: SIZE * SIZE,
              itemBuilder: (context, int index) {
                return _buildGameCell(0);
              },
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildGameCell(int value) {
    return Text(
      value == 0 ? "" : value.toString(),
    );
  }

  /// 游戏结束时盖在 Panel 上的蒙层
  Widget _buildGameOverMask(BuildContext context) {
    return AspectRatio(
        aspectRatio: 1.0,
        child: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text("Game Over"),
              ElevatedButton(
                  onPressed: () {
                    // 重新开始游戏
                  },
                  child: Text("ReStart"))
            ],
          ),
        ));
  }
}
```

这里有几个小细节我觉得还可以说一下，一个是使用 GridView 的时候，顶部默认会有一个 Padding，这样会影响最后展示的效果，所以这里用 `MediaQuery.removePadding()` 组件包裹了 GridView，并且设置 `removeTop` 为 true，就可以去掉这部分的 padding。第二个是默认 GridView 是可以滚动的，而这里我们不希望它滚动，所以给 GridView 的 `physics` 属性设置为 `NeverScrollableScrollPhysics`，这样就禁用了它的滚动。

到这一步，我们就可以构建出如下所示的 UI 界面：

<img src="https://gitee.com/owenlee233/image_store/raw/master/202110241727651.png" alt="just-ui" style="zoom:33%;" />



### 逻辑实现

构建好基础的 UI，我们就可以进一步开始编写逻辑实现了。

首先我们先来构造这个游戏的数据源，4 * 4 的棋盘，棋盘中每个格子要么是空的，要么是数字，我们很容易能想到用一个 int 的二维数组来表示它，空格子我们用 0 来表示。

```dart
// Game2048Panel
// 数据源，类型是 List<List<int>>
List _gameMap = List.generate(SIZE, (_) => List<int>.generate(SIZE, (_) => 0));
```

在小格子 Cell 中，我们通过将 GridView 的 index 转化为二维数组的

