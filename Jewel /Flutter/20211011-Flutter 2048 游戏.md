最近在学习 Flutter 的一些知识，想着独立写一个小示例来运用一下所学的东西，所以就有了这个Flutter 版本 2048 小游戏的项目。完整代码请戳 [Github]()。

2048 小游戏曾经也是风靡一时呀，应该很多人都玩过，不过我们还是简单说一下这个游戏的机制，这里有个网页版的 [2048](https://play2048.co/)，大家可以实际体验一下。一般来说，它是一个 4 * 4 的棋盘，共有 16 个小格子，每个格子中，要么是空格，要么有一个数字，玩家可以上下左右四个方向去滑动（或者通过键盘方向键控制）。当左右滑动时，同一行上数字格子会被移到最左端或者最右端，中间没有空格，相邻的相同数字的格子合并成一个，数字是之前两个格子数字之和，比如 2 和 2 会合并成 4 和 空格。每次滑动后有格子移动时，就会在棋盘的空格里随机生成一个数字。终极的目标是合并出 2048 这个数字。

好的，介绍完这个游戏怎么玩后，我们就可以进入正题，开始实现我们 Flutter 版本的 2048 了。

我们最终实现的效果如下：

<img src="https://gitee.com/owenlee233/image_store/raw/master/202110241555714.png" alt="UI" style="zoom:33%;" />

### UI 界面

从上面的效果图我们可以看到，这个游戏界面可以分为两部分，一个是上方的标题、分数、历史最高分、重新开始游戏按钮等元素：

<img src="https://gitee.com/owenlee233/image_store/raw/master/202110241558113.png" alt="header" style="zoom:33%;" />

一个是下方的棋盘部分，有 4 * 4 个小格子：

<img src="https://gitee.com/owenlee233/image_store/raw/master/202110241559350.png" alt="panel" style="zoom:33%;" />

如果游戏结束时，这部分上面还会盖有一个游戏结束的蒙层：

<img src="https://gitee.com/owenlee233/image_store/raw/master/202110241601378.png" alt="mask" style="zoom:33%;" />

游戏整体 UI 的代码，精简一下是这样的：

```dart
class Game2048Page extends StatefulWidget {
  @override
  _Game2048PageState createState() => _Game2048PageState();
}

class _Game2048PageState extends State<Game2048Page> {

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      extendBodyBehindAppBar: true,
      body: Container(
        padding: EdgeInsets.only(top: 30),
        color: GameColors.bgColor1,
        child: Column(
          children: [
            Flexible(child: gameHeader()),
            Flexible(flex: 2,child: Game2048Panel())
          ],
        )
      ),
    );
  }

  // 省略了代码
  Widget gameHeader() {
    return Container();
  }
}
```

因为界面里需要展示变化的当前分数和历史最高分数，所以 `Game2048Page` 是继承自 `StatefulWidget`。布局结构整体是一个 Column 的垂直方向布局，上面是 `gameHeader()`，抽成了一个方法，里面就是标题、描述、分数等信息，下面是 `Game2048Panel` 表示棋盘，定义成了一个 Widget，Header 和 Panel 是 1 ：2 的高度比例（这个后面会提到是干嘛的）。

#### Header 部分

Header 部分比较简单，就粗略介绍一下，我们需要展示当前的分数和历史最高分，所以在 `_Game2048PageState` 中定义两个变量，并在相应的 UI 元素中展示出来，分数下方还有个 New Game 的按钮，点击按钮可以重新开始游戏。这部分 UI 代码精简后是这样的，重新开始游戏的逻辑我们后面再实现。

```dart
class _Game2048PageState extends State<Game2048Page> {

  /// 当前分数
  int currentScore = 0;
  /// 历史最高分
  int highestScore = 0;
 
  Widget gameHeader() {
  	return Row(
    	children: [
        Text("2048"),
        Column(
          children: [
            Text(currentScore.toString()),
            Text(highestScore.toString()),
            ElevatedButton(
            	onPressed: () {
                // 重新开始游戏，这里的逻辑之后再实现
              },
              child: Text("New Game"),
            )
          ]
        ),
      ]
    )
  }
}
```

#### Panel 部分

Panel 部分我定义成了一个叫做 Game2048Panel 的 Widget，继承自 StatefulWidget，因为内部有是否游戏结束等状态。UI 部分，当游戏结束时，我们使用 Stack 布局，蒙层盖在棋盘的上方，游戏没有结束时，只有棋盘。棋盘宽高比是 1 : 1，使用 AspectRatio 组件，棋盘可以识别用户上下左右滑动的手势，所以需要 GestureDetector 组件，棋盘中 4 * 4 的小格子，用 GridView 来实现。`Game2048Panel` 的 UI 结构大致如下图所示：

![panel-ui](https://gitee.com/owenlee233/image_store/raw/master/202110241710234.png)

这部分整体的代码精简一下（去掉了 UI 细节）是这样的：

```dart
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter_games/games/2048/game_colors.dart';

class Game2048Panel extends StatefulWidget {
  final ValueChanged<int>? onScoreChanged;

  Game2048Panel({Key? key, this.onScoreChanged}) : super(key: key);

  @override
  Game2048PanelState createState() => Game2048PanelState();
}

class Game2048PanelState extends State<Game2048Panel> {
  /// 每行每列的个数
  static const int SIZE = 4;

  /// 判断是否游戏结束
  bool _isGameOver = false;

  @override
  Widget build(BuildContext context) {
    if (_isGameOver) {
      return Stack(
        children: [
          _buildGamePanel(context),
          _buildGameOverMask(context),
        ],
      );
    } else {
      return _buildGamePanel(context);
    }
  }

  Widget _buildGamePanel(BuildContext context) {
    return GestureDetector(
      child: AspectRatio(
        aspectRatio: 1.0,
        child: Container(
          child: MediaQuery.removePadding(
            /// GridView 默认顶部会有 padding，通过这个删除顶部 padding
            removeTop: true,
            context: context,
            child: GridView.builder(
              /// 禁用 GridView 的滑动
              physics: const NeverScrollableScrollPhysics(),
              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: SIZE,
              ),
              itemCount: SIZE * SIZE,
              itemBuilder: (context, int index) {
                return _buildGameCell(0);
              },
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildGameCell(int value) {
    return Text(
      value == 0 ? "" : value.toString(),
    );
  }

  /// 游戏结束时盖在 Panel 上的蒙层
  Widget _buildGameOverMask(BuildContext context) {
    return AspectRatio(
        aspectRatio: 1.0,
        child: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text("Game Over"),
              ElevatedButton(
                  onPressed: () {
                    // 重新开始游戏
                  },
                  child: Text("ReStart"))
            ],
          ),
        ));
  }
}
```

这里有几个小细节我觉得还可以说一下，一个是使用 GridView 的时候，顶部默认会有一个 Padding，这样会影响最后展示的效果，所以这里用 `MediaQuery.removePadding()` 组件包裹了 GridView，并且设置 `removeTop` 为 true，就可以去掉这部分的 padding。第二个是默认 GridView 是可以滚动的，而这里我们不希望它滚动，所以给 GridView 的 `physics` 属性设置为 `NeverScrollableScrollPhysics`，这样就禁用了它的滚动。

到这一步，我们就可以构建出如下所示的 UI 界面：

<img src="https://gitee.com/owenlee233/image_store/raw/master/202110241727651.png" alt="just-ui" style="zoom:33%;" />



### 逻辑实现

构建好基础的 UI，我们就可以进一步开始编写逻辑实现了。

#### 数据源及游戏初始化

首先我们先来构造这个游戏的数据源，4 * 4 的棋盘，棋盘中每个格子要么是空的，要么是数字，我们很容易能想到用一个 int 的二维数组来表示它，空格子我们用 0 来表示。

```dart
// Game2048Panel
// 数据源，类型是 List<List<int>>
List _gameMap = List.generate(SIZE, (_) => List<int>.generate(SIZE, (_) => 0));
```

在小格子 Cell 中，我们通过将 GridView 的 index 转化为二维数组的坐标，从 _gameMap 中取出数据显示在 Cell 中。

```dart
GridView.builder(
  itemCount: SIZE * SIZE,
  itemBuilder: (context, int index) {
    int indexI = index ~/ SIZE;
    int indexJ = index % SIZE;
    return _buildGameCell(_gameMap[indexI][indexJ]);
  },
),
```

```dart
Widget _buildGameCell(int value) {
  return Container(
    decoration: BoxDecoration(
      color: GameColors.mapValueToColor(value),  // 数值和背景颜色有个映射
      borderRadius: BorderRadius.circular(5),
    ),
    child: Center(
      child: Text(
        value == 0 ? "" : value.toString(), // 如果数字是0，展示空字符串，效果上就是空格，否则展示数字
      ),
    ),
  );
}
```

这样我们数据的展示就完成了。因为一开始 _gameMap 中都是 0，所以这步完成后，棋盘里都是空格，我们可以 Mock 一些数据，看看实际显示效果。这里我们写一个在 _gameMap 中随机坐标生成一个非 0 数字的函数 `_randomNewCellData`：

```dart
/// 在 gameMap 里随机位置放置指定的数字，
/// 需要刷新界面时，需要将这个函数放在 setState 里
void _randomNewCellData(int data) {
  /// 在产生新的数字（块）时，
  /// 需要先判断下是否map中所有的数字都不为0
  /// 如果都不为0，就直接return，不产生新数字
  if (isGameMapAllNotZero()) {
    debugPrint("gameMap中都不是0，不能生成");
    return;
  }
  while (true) {
    Random random = Random();
    int randomI = random.nextInt(SIZE);
    int randomJ = random.nextInt(SIZE);
    if (_gameMap[randomI][randomJ] == 0) {
      _gameMap[randomI][randomJ] = data;
      break;
    }
  }
}

/// 判断Map中的数字是否都不为0
bool isGameMapAllNotZero() {
  bool isAllNotZero = true;
  for (int i = 0; i < SIZE; i++) {
    for (int j = 0; j < SIZE; j++) {
      if (_gameMap[i][j] == 0) {
        isAllNotZero = false;
        break;
      }
    }
  }
  return isAllNotZero;
}
```

这是一个简单的随机算法，判断 _gameMap 中的数是否都不为 0，如果都不为 0，则返回；否则就随机生成一组行列坐标，如果这个坐标上的数是 0，就给这个坐标赋一个非 0 值，如果这个坐标上的数不是 0，则继续随机生成一组坐标，直到生成坐标上的数是 0 为止。

然后在 `initState` 调用这个方法，就可以初始化游戏数据啦，我们默认随机生成一个 2 和一个 4。

```dart
@override
void initState() {
  super.initState();
  _initGameMap();
}

/// 初始化数据
void _initGameMap() {
  /// 执行两次随机
  _randomNewCellData(2);
  _randomNewCellData(4);
}
```

现在运行程序，就可以看到随机放置数字小块的效果啦：

<img src="https://gitee.com/owenlee233/image_store/raw/master/202110241559350.png" alt="panel" style="zoom:33%;" />

#### 滑动手势操作

接下来非常重要的一步就是要识别用户上下左右滑动的手势，因为对 `GestureDetector` 的 API 不了解，不确定是否有更简单的做法，我这里的实现方式和 Android 的手势识别比较接近，在 `onPanDown` 时，记录下手指的下落坐标，在 `onPanUpdate` 里，记录下当前的坐标，如果当前坐标 - 下落坐标在水平方向的距离 > 设定的主轴最小阈值，并且当前坐标 - 下落坐标在垂直方向的距离 < 设定的交叉轴最大阈值，就表示是水平方向的滑动，反之则是垂直方向的滑动，再比较在主轴方向上当前坐标和下落坐标的大小，可以进一步判断出是向左滑动还是向右滑动（向上滑动还是向下滑动）。

```dart
/// 当上下滑动时，左右方向的偏移应该小于这个阈值，左右滑动亦然
double _crossAxisMaxLimit = 20.0;

/// 当上下滑动时，上下方向的偏移应该大于这个阈值，左右滑动亦然
double _mainAxisMinLimit = 60.0;

/// onPanUpdate 会回调多次，只需要第一次有效的就可以了，
/// 在 onPanDown 时设为 true，第一次有效滑动后，设为 false
bool _firstValidPan = true;

GestureDetector(
  onPanDown: (DragDownDetails details) {
    lastPosition = details.globalPosition;
    _firstValidPan = true;
  },
  onPanUpdate: (DragUpdateDetails details) {
    final currentPosition = details.globalPosition;

    /// 首先区分是垂直方向还是水平方向滑动
    if ((currentPosition.dx - lastPosition.dx).abs() > _mainAxisMinLimit &&
        (currentPosition.dy - lastPosition.dy).abs() < _crossAxisMaxLimit) {
      // 水平方向滑动
      if (_firstValidPan) {
        debugPrint("水平方向滑动");
        /// 然后区分是向左滑还是向右滑
        if (currentPosition.dx - lastPosition.dx > 0) {
          // 向右滑
          debugPrint("向右滑");
        } else {
          // 向左滑
          debugPrint("向左滑");
        }
        _firstValidPan = false;
      }
    } else if ((currentPosition.dy - lastPosition.dy).abs() > _mainAxisMinLimit &&
        (currentPosition.dx - lastPosition.dx).abs() < _crossAxisMaxLimit) {
      // 垂直方向滑动
      if (_firstValidPan) {
        debugPrint("垂直方向滑动");
        /// 然后区分是向上滑还是向下滑
        if (currentPosition.dy - lastPosition.dy > 0) {
          // 向下滑
          debugPrint("向下滑");
        } else {
          // 向上滑
          debugPrint("向上滑");
        }
        _firstValidPan = false;
      }
    }
  },
}
```

这段代码里还有一个变量 `_firstValidPan` 需要解释下，因为 `onPanUpdate` 在手指滑动过程中会一直回调，所以当我们识别到一个有效的滑动（判断出明确的方向）时，后续的 onPanUpdate 就不需要处理了，记得需要在 onPanDown 中重置这个变量。

现在运行代码，我们在棋盘里用手指上下左右滑动，可以打印出正确的手势滑动方向。

